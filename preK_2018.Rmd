---
title: "Pre-K 2018"
output:  html_document
---
# Load Libraries

```{r message=FALSE, warning=FALSE}
library(Hmisc) # cut2 for binning
#library(choroplethr)
#not on CRAN. Do an install the first time
#devtools::install_github('arilamstein/choroplethrZip@v1.5.0')
#library(choroplethrZip)
#library(acs)  # retrieve census data
#library(stringr)
library(reshape2)
#library(cowplot)
#library(jpeg)
library(tidyverse)
library(tidycensus)
library(tigris)
library(sf)
library(pdftools)
#devtools::install_github("r-spatial/mapview@develop")
library(mapview)

```

```{r}
# download and scrape NYC PRE-K pdf directories
# -----------------------------------------------------------------------
# get NYC data on pre-K programs in 2018
# scan seat directory pdfs and put into a data frame by zip code
#DOE pre-k directories



#urls valid as of November 2018
urls<-c("https://www.schools.nyc.gov/docs/default-source/default-document-library/2018nycprekdirectorybronx-english",
        "https://www.schools.nyc.gov/docs/default-source/default-document-library/nyc-pre-kindergarten-directory-brooklyn",
        "https://www.schools.nyc.gov/docs/default-source/default-document-library/2018-nyc-prek-directory-manhattan-english",
        "https://www.schools.nyc.gov/docs/default-source/default-document-library/2018nycprekdirectoryqueens-english",
        "https://www.schools.nyc.gov/docs/default-source/default-document-library/2018nycprekdirectorystatenislandenglishweb-english")

boroughs <- c('Bronx','Brooklyn','Manhattan','Queens','Staten')

dests <- paste0("pdf/",boroughs,"2018_Pre_K.pdf")

# Download PDF directories from NYC if PDFs are not already present
if (!is.na(match(FALSE,file.exists(dests)))) {
  for (i in 1:length(urls)) {
    download.file(urls[i],destfile = dests[i],mode = "wb")
  }
}
```

Extract text from PDFs.  Select only those pages that are directory listings and split into lines.
```{r}
if (!file.exists("data/schools_2018.rdata")){
  # extract and combine text from PDFs
  listings <- NULL
  for (i in 1:length(dests)) {
    print(dests[i])
    txt <- suppressMessages(pdf_text(dests[i]))
    # "Playspace:" is marker for actual directory listing of pre-k schools on that page
    # Discard other pages
    txt <- txt[str_detect(txt,"Playspace:")]
    txt <- txt[-1] #first instance is an example page. discard.
    listings <- append(listings,txt)
    # file.remove(dests[i])
  }
  
  #text is in one page per item
  #divide listings into separate lines
  listings <- listings %>% str_split("\\r?\\n") %>% unlist()
}
```

Detect record boundaries and turn list of lines into a clean data frame of school listings.
```{r}
if (!file.exists("data/schools_2018.rdata")){
  # regex to extract valid address
  #addresstokens <-"(Address: )['-./0-9 A-Za-z]+,[0-9 A-Za-z]+([0-9]{5})"
  addresstokens <-"(Address: ).+([0-9]{5})"
  #use lines containing address as anchor to mark record boundaries
  lines_address<-grep(addresstokens,listings)
  record_start<-lines_address-1
  record_end<-(lines_address-2)[-1] %>% append(length(listings))
  
  #----------------------------
  #workhorse function to create a record with all relevant info about a school
  create_record <- function(rec_index){
    #rec <- listings[record_boundaries[rec_index,]$start:record_boundaries[rec_index,]$end]
    rec <- listings[record_start[rec_index]:record_end[rec_index]]
    name <- str_extract(rec[1],"(.+)(?=\\|)") %>% str_trim()
    district <- str_extract(rec[1],"(?<=\\| )[0-9]{2}") %>% str_trim() %>% as.integer()
    address <- str_extract(rec[2],addresstokens)%>% str_remove("Address: ")
    zip <- str_extract(address,"[0-9]{5}$")
    address <- str_remove(address," [0-9]{5}$")
    borough <- address %>% str_extract("[A-z]+(?= NY)")
    # the next two searches should be tolerant of not knowing line the field is on
    day_length <- str_extract(rec,"([A-Za-z]+)(?=-Day)")  %>% na.omit() %>% as.character() %>% .[1]
    seats = str_extract(rec,"(?<=Seats: )[0-9]+") %>% na.omit() %>% as.integer() %>% .[1]
    return(data_frame(name=name,
                      address=address,
                      zip=zip,
                      borough = borough,
                      district = district,
                      seats = seats,
                      day_length=day_length))
    
  }
  #----------------------------
  
  #create data frame with a line for each school
  schools_2018 <- 1:length(record_start) %>% map(create_record) %>% bind_rows()
  schools_2018 <- schools_2018 %>% mutate(borough = ifelse(borough=="Island","Staten",borough))
  save(schools_2018,file="data/schools_2018.rdata")
}
```
Get census data
Income, population, population of school age children and census zip code geometries.

Here, I am making an aesthetic choice. I want to use wide, not tidy data because duplicating the map data for every variable seems wasteful and doing math on multiple variables is easier with wide data.  `get_acs` will optionally return wide data but I don't like the column names.

```{r message=FALSE, warning=FALSE}
if (!file.exists("data/schools_2018.rdata")){
  
  # I keep my census api key in a system variable. This adds it to the r environment 
  # with a label that tidycensus expects.
  #if (nchar(Sys.getenv("CENSUS_API_KEY"))==0) 
  
  #census_api_key(Sys.getenv("CENSUS_API_KEY"))
  
  options(tigris_use_cache = TRUE)
  
  # get zip code boundaries from Tigris
  geo_nyc_zips_raw <-zctas(cb = FALSE, 
                           starts_with = c("10","11"),
                           state = "NY",
                           year = 2010,
                           class = "sf")
  
  geo_nyc_zips <- geo_nyc_zips_raw %>% rename(zip= ZCTA5CE10) %>% select(zip,geometry)
  
  #The returned set of geometries includes long island and Westchester so
  #crop the bounding box to get a better sized map.
  nyc_box<-c(xmin=-74.5,ymin=40.5,xmax=-73.6,ymax=41.0)
  geo_nyc_zips <-geo_nyc_zips %>%  st_crop(nyc_box)
  save(geo_nyc_zips,file="data/geo_nyc_zips.rdata")
  # FYI if you want to see all the available acs tables from the census bureau
  # v15 <- load_tvariables(2016, "acs5", cache = TRUE)
  # View(v15)
  
  acs_table_pop <- "B01003_001" # total population
  acs_table_kid <- "B05009_002" # children under 6
  acs_table_inc <- "B19013_001" # median income, last 12 months
  # NYC county codes
  #nyc_fips = c("085","005", "047", "061", "081") # use as "county"
  #nyc_geoids = c("36085","36005", "36047", "36061", "36081")
  nyc_zips <- read_tsv("data/nyc zip codes.txt") %>% rename(zip=ZIP) # this comes from USPS web site
  
  # we can only use the zcta (zip code) geography if we fetch the whole country!
  acs_raw <- get_acs(geography = "zcta",
                     variables = c(HouseholdIncome = acs_table_inc,
                                   kidsUnder3 = acs_table_kid,
                                   totPop = acs_table_pop))
  # filter for just NYC zip codes
  # and make the data wide
  acs_dat<- acs_raw %>% 
    rename(zip=GEOID) %>% 
    right_join(nyc_zips) %>% 
    select(zip,variable,estimate) %>% 
    filter(!is.na(variable)) %>% 
    spread(variable,estimate) %>% 
    filter(!is.na(HouseholdIncome)) %>% 
    {.}
  
  save(acs_dat,file="data/acs_dat.rdata")
}
```
# Get to work
Now we have everything we need to make some maps: the schools data from the city, the population and income data from the census and the map coordinates for all NYC zip codes. Let's bring them together.

```{r}
load("data/schools_2018.rdata")
load("data/alldata2018.rdata")
load("data/acs_dat.rdata")
load("data/geo_nyc_zips.rdata")


# aggregate seat count by zip code

sum_seats <- schools_2018 %>% 
  group_by(zip) %>% 
  summarise(schools = n(), 
            numSeats = sum(seats, na.rm = TRUE))

all_data_2018 <- geo_nyc_zips %>% 
  left_join(acs_dat,by="zip") %>% 
  left_join(sum_seats,by="zip") %>% 
  # remove non-NYC geometries
  filter(!is.na(HouseholdIncome)) %>% 
  # some tiny zips have people but no schools.  Set schools to zero.
  mutate(schools=ifelse(is.na(schools),0,schools)) %>% 
  mutate(numSeats=ifelse(schools==0,0,numSeats)) 
  

#add per-capita variables
all_data_2018 <- all_data_2018 %>% 
  mutate(seatsPer100Kids = round(numSeats/kidsUnder3*100,digits=1),
         seatsPer1000People=round(numSeats/totPop*1000,digits=1)) %>%
  mutate(seatsPer100Kids=ifelse(is.nan(seatsPer100Kids),0,seatsPer100Kids))
#compute income quantiles
fn<-ecdf(all_data_2018$HouseholdIncome)
all_data_2018 <- all_data_2018 %>% 
  mutate(incomeQuantile=fn(HouseholdIncome))
#compute seatsPer100Kids quantiles
fn<-ecdf(all_data_2018$seatsPer100Kids)
all_data_2018 <- all_data_2018 %>% 
  mutate(seatsQuantile=fn(seatsPer100Kids))
# aggregate quantiles into three categorical bins
bins<-3
all_data_2018 <- all_data_2018 %>% 
  mutate(seatsBin=cut2(seatsQuantile,g=bins,levels.mean = TRUE)) %>% 
  mutate(incomeBin=cut2(incomeQuantile,g=bins,levels.mean = TRUE))
#recode numeric bins to descriptions
levels(all_data_2018$seatsBin) = c("Few","Average","Many")
levels(all_data_2018$incomeBin) = c("Low","Average","High")

save(all_data_2018,file="data/alldata2018.rdata")
```
#The Problem with a Univariate Approach

Initially, we can just view a scatter plot of the quantiles.  Here we see that there is scant relationship between zip code income and per-child seats over most of the range.  The is a cluster of high-income zip codes at the lower end of the seat count.  This alone discounts the notion that the wealthy are getting more than their fair share of seats.
```{r message=FALSE}
ggplot(all_data_2018,aes(incomeQuantile,seatsQuantile))+geom_point()+geom_smooth()

```

We are used to seeing univarate color maps but here we have two values, seats and income.  How might we code them into one variable. Given the social justice element of the original question, we might create a single scale of good to bad. So, for our purposes, high income and low seats is "good" along with low income and high seats.  Simply taking the difference between income and seats quantiles works.  The largest differences are "good.""

```{r}
#combine income and seats into single factor, ordered
#by "desirability."
all_data_2018 <- all_data_2018 %>% 
  mutate(combo = abs(seatsQuantile - incomeQuantile))

mapview(all_data_2018,zcol=c("combo"),
        map.types="OpenStreetMap.BlackAndWhite",
        layer.name =  "Affirmative Tilts",
        popup = NULL)
```

It is so easy to make great looking maps now!

There are problems with our analytic approach, though.  We have shoehorned two variables, income and seats into one, hard to interpret feature.  I label it "Affirmative Tilts."  Higher values mean more discrepency between the income quantile and the seats quantile which we call "good" but there is no real intuition behind the number.  Second, much of the value of the map is lost. We don't know which zip codes are high or low income, or have plenty or few seats - just that their is a big or small difference between the values.  To really tell the story we need to show two variables simultaneously on the map.

To create a bivariate map we add a new factor that is the character combination of the income bin and the seat count bin.

```{r}
ordered_combos <- c("Low, Few",
                    "Low, Average",
                    "Low, Many",
                    "Average, Few",
                    "Average, Average",
                    "Average, Many",
                    "High, Few",
                    "High, Average",
                    "High, Many")

bvColors=c("#be64ac","#8c62aa","#3b4994","#dfb0d6","#a5add3","#5698b9","#e8e8e8","#ace4e4","#5ac8c8")

all_data_2018 <- all_data_2018 %>% 
  mutate(IncAndSeats = factor(paste0(incomeBin,", ",seatsBin),
                        levels = ordered_combos))

# Decide what we want to show when user clicks on a zip code.
# Do a lot of cleanup of the resulting HTML strings.
popup_html<-popupTable(all_data_2018,
           zcol=c("IncAndSeats","HouseholdIncome","kidsUnder3", "seatsPer100Kids","zip"),
           row.numbers = FALSE) %>% 
  # this does comma formatting of the HTML string for income.  Thanks, Stack Overflow!
  str_replace("(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))",",") %>% 
  #get rid of superfluous features
  str_replace("<tr><td><\\/td><td><b>geometry.+\\/tr>","") %>% 
  str_replace("(<td><b>Feature ID.*?\\/tr>)(?=<tr class)","") %>% 
  # make feature labels nicer looking
  str_replace("IncAndSeats","Income and Seats") %>%
  str_replace("HouseholdIncome","Median Income") %>%
  str_replace("kidsUnder3","Young Children") %>%
  str_replace("seatsPer100Kids","Seats per 100 Kids") %>%
  str_replace("zip","ZIP Code") %>%
  {.}
  

mv <-mapview(all_data_2018,zcol=c("IncAndSeats"),
        popup = popup_html,
        col.regions = bvColors,
        map.types="OpenStreetMap.BlackAndWhite",
        layer.name = "Income and Seats 2018")


```

So there's the map.  We can immediately see the problem with the default legend, it's uni-dimensional nature of the legend even though we have a bi-variate color scheme.

Here is where the interesting hack comes in.  No mapping packages I am aware of have a facility for a bivariate legend.  The beautiful plots Joshua Stevens shows on his web page use a dedicated graphic composition program.  Can we cobble something up in R in `mapview`?  Yes!  The `mapview` package allows for insertion of images.

## Create the custom legend.
To create the legend we 'simply' create a heat map of the 3x3 bins in the map and label the axes appropriately and save the image.  Then, using `addlogo(), shove it into a corner of the map.
```{r message=FALSE}

#first create a legend plot
legendGoal = melt(matrix(1:9, nrow = 3))
lg <- ggplot(legendGoal, aes(Var2, Var1, fill = as.factor(value))) + geom_tile()
lg <- lg + scale_fill_manual(name = "", values = bvColors)
lg <- lg + theme(legend.position = "none")
lg <- lg + theme(axis.title.x = element_text(size = rel(0.5), color = bvColors[3])) + 
  xlab(" More Income -->")
lg <- lg + theme(axis.title.y = element_text(size = rel(0.5), color = bvColors[3])) + 
  ylab("   More Seats -->")
lg <- lg + theme(axis.text = element_blank())
lg <- lg + theme(line = element_blank())
ggsave("img/bv_legend.png",lg,width = 20,height=20,units="mm")

```

Now render the map.
```{r}
mv <- mapview(all_data_2018,zcol=c("IncAndSeats"),
        popup = popup_html,
        col.regions = bvColors,
        map.types="OpenStreetMap.BlackAndWhite",
        layer.name = "Income and Seats",
        legend = FALSE)

#mv <-mv %>% addLogo("img/bv_legend.png",src = "local",
#                    position = "topleft",width=100,height=100,offset.x = 70)
mv
```

Bonus! Compare 2016 to 2018
```{r}
# aggregate seat count by borough


sumSeats2018 <- schools_2018 %>% 
  group_by(borough) %>% 
  summarise(schools = n(), 
            numSeats = sum(seats, na.rm = TRUE)) %>% 
  mutate(year=as.integer(2018))


load("data/alldata2016.rdata") 
all_data_2016 <-allData
rm(allData)
#2016 data doesn't have boroughs so map zips to boroughs from 2018 data
sumSeats2016<-schools_2018 %>% select(borough,zip) %>% 
  unique() %>% 
  right_join(all_data_2016,by=c("zip")) %>%
  select(borough,schools,numSeats) %>% 
  group_by(borough) %>% 
  summarise(schools = sum(schools), 
            numSeats = sum(numSeats, na.rm = TRUE)) %>% 
  mutate(year=as.integer(2016))

sumSeats <- bind_rows(sumSeats2016,sumSeats2018) %>% mutate(year=as.factor(year))
ggplot(sumSeats,aes(borough,schools,fill=year)) + 
  geom_col(position = "dodge") + 
  scale_y_continuous(labels=scales::comma) + 
  labs(title = "Expansion of NYC Free Pre-K",
       caption = "source: nyc.gov",
       x = "Borough",
       y = "Number of Schools")
```

```{r}
ggplot(sumSeats,aes(borough,numSeats,fill=year)) + 
  geom_col(position = "dodge") + 
  scale_y_continuous(labels=scales::comma) +
  labs(title = "Expansion of NYC Free Pre-K",
       caption = "source: nyc.gov",
       x = "Borough",
       y = "Number of Seats")

```

```{r}
load("data/alldata2016.rdata") 
all_data_2016 <-allData
rm(allData)

seats_delta<- all_data_2018 %>% 
  select(zip,geometry,numSeats) %>% 
  rename(numSeats_2018=numSeats) %>% 
  left_join(all_data_2016) %>% 
  na.omit() %>% 
  rename(numSeats_2016=numSeats) %>% 
  mutate(zip=zip,
         seatsPctChange16to18=round((numSeats_2018/numSeats_2016-1)*100,0)) %>% 
  select(zip,numSeats_2016,numSeats_2018,seatsPctChange16to18) %>% 
  {.}

# chop down huge percentages
seats_delta <- seats_delta %>% 
  mutate(seatsPctChange16to18 = ifelse(seatsPctChange16to18>200,200,seatsPctChange16to18))

#add spatial geometry to 2016 data
all_data_2016 <- all_data_2018 %>% 
  select(zip,geometry) %>% 
  left_join(all_data_2016) %>% 
  na.omit() %>% 
  mutate(IncAndSeats = factor(paste0(incomeBin,", ",seatsBin),
                        levels = ordered_combos))


popup_html_2016<-popupTable(all_data_2016,
           zcol=c("IncAndSeats","HouseholdIncome","kidsUnder3", "seatsPer100Kids","zip"),
           row.numbers = FALSE) %>% 
  # this does comma formatting of the HTML string for income.  Thanks, Stack Overflow!
  str_replace("(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))",",") %>% 
  #get rid of superfluous features
  str_replace("<tr><td><\\/td><td><b>geometry.+\\/tr>","") %>% 
  str_replace("(<td><b>Feature ID.*?\\/tr>)(?=<tr class)","") %>% 
  # make feature labels nicer looking
  str_replace("IncAndSeats","Income and Seats") %>%
  str_replace("HouseholdIncome","Median Income") %>%
  str_replace("kidsUnder3","Young Children") %>%
  str_replace("seatsPer100Kids","Seats per 100 Kids") %>%
  str_replace("zip","ZIP Code") %>%
  {.}

mv_2016 <- mapview(all_data_2016,zcol=c("IncAndSeats"),
        popup = popup_html_2016,
        col.regions = bvColors,
        map.types="OpenStreetMap.BlackAndWhite",
        layer.name = "Income and Seats 2016",
        legend = FALSE) %>% 
    #addLogo("img/bv_legend.png",src = "local",
    #        position = "topleft",width=100,height=100,offset.x = 70) %>%
    {.}


  
  

mv_delta<- mapview(seats_delta,zcol=c("seatsPctChange16to18"),
                   popup = popup_html,
                   map.types="OpenStreetMap.BlackAndWhite",
                   layer.name = "Change in Seats\n 2016-2016") %>% 
  {.}


#mv_all %>%   leaflet::addLayersControl(overlayGroups=c("Income and Seats 2016",
#                           "Income and Seats 2018",
#                           "Change in Seats 2016-2016"))


```

Try all this in leaflet
```{r}
# This largely follows the leaflet tutorial at
# https://rstudio.github.io/leaflet/choropleths.html

library(leaflet)

pal <- colorFactor(bvColors, domain = all_data_2018$IncAndSeats)

popup_html<-popupTable(all_data_2018,
           zcol=c("IncAndSeats","HouseholdIncome","kidsUnder3", "seatsPer100Kids","zip"),
           row.numbers = FALSE) %>% 
  # this does comma formatting of the HTML string for income.  Thanks, Stack Overflow!
  str_replace("(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))",",") %>% 
  #get rid of superfluous features
  str_replace("<tr><td><\\/td><td><b>geometry.+\\/tr>","") %>% 
  str_replace("(<td><b>Feature ID.*?\\/tr>)(?=<tr class)","") %>% 
  # make feature labels nicer looking
  str_replace("IncAndSeats","Income and Seats") %>%
  str_replace("HouseholdIncome","Median Income") %>%
  str_replace("kidsUnder3","Young Children") %>%
  str_replace("seatsPer100Kids","Seats per 100 Kids") %>%
  str_replace("zip","ZIP Code") %>%
  lapply(htmltools::HTML) %>% 
  {.}

#convert an image file to base 64 to embed raw data in HTML
img_html <- function(img,height=100,width=100,alpha = 1){
  style <- paste0('style="opacity:',
                  alpha,
                  ';filter:alpha(opacity=',
                  alpha * 100, ');"')
txt <- RCurl::base64Encode(readBin(img, "raw", file.info(img)[1, "size"]), "txt")

# Create inline image, save & open html file in browser 
#html <- sprintf('<html><body><img src="data:image/png;base64,%s"></body></html>', txt)
html<- paste0("<html><body<img src='data:image/png;base64'",
              txt,
              ", width=", width,",",
              "height=", height,",",
              style,
              "</body></html>") %>% 
  htmltools::HTML()

}


popup_html <- with(all_data_2018,
                   paste0("<strong>ZIP Code :",zip,
                          "<br/>Income and Seats: ",IncAndSeats, "</strong>",
                          "<br/>Median Income: $",format(HouseholdIncome,big.mark = ","),
                          "<br/>Young Children: ",format(kidsUnder3,big.mark = ","),
                          "<br/>Seats per 100 Kids: ",seatsPer100Kids)) %>% 
  lapply(htmltools::HTML)


all_data_2018 %>% 
  leaflet() %>% 
  addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>% 
  addPolygons(
  fillColor = ~pal(IncAndSeats),
  weight = 1,
  opacity = 1,
  color = "black",
  dashArray = "",
  fillOpacity = 0.7,
  highlight = highlightOptions(
    weight = 5,
    color = "black",
    dashArray = "",
    fillOpacity = 0.7,
    bringToFront = TRUE),
  label = popup_html
  ) %>% 
  addControl(img_html("img/bv_legend.png"),position="topleft")


```
